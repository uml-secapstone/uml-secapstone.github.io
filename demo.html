<!DOCTYPE HTML>
<!--
    Editorial by HTML5 UP
    html5up.net | @ajlkn
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        
        
    </head>
    <body class="is-preload">

        <!-- Wrapper -->
        <div id="wrapper">

            <!-- Main -->
            <div id="main">
                <div class="inner">

                    <!-- Demo Section -->
                    <section>
                        <header class="main">
                            <h1>Neural Network Demo</h1>
                        </header>

                        <!-- Visualization Containers -->
                        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
						<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0"></script>
						<style>
							.container { display: flex; gap: 20px; padding: 20px; }
							.controls { width: 250px; }
							.visualization { flex-grow: 1; }
							.network-canvas { border: 1px solid #ccc; }
							.layer-control { margin: 10px 0; }
							button { margin: 5px; padding: 5px 10px; }
							.feature-controls { margin: 20px 0; }
						</style>

<body>
    <div class="container">
        <div class="controls">
            <h2>Controls</h2>
            
            <!-- Network Architecture -->
            <div class="layer-controls">
                <h3>Network Layers</h3>
                <div id="layerControls"></div>
                <button onclick="addLayer()">+ Add Layer</button>
                <button onclick="removeLayer()">- Remove Layer</button>
            </div>

            <!-- Hyperparameters -->
            <div class="hyperparams">
                <h3>Training Parameters</h3>
                <label>Learning Rate: <input type="number" id="learningRate" value="0.01" step="0.001"></label>
                <label>Epochs: <input type="number" id="epochs" value="50"></label>
                <label>Batch Size: <input type="number" id="batchSize" value="32"></label>
            </div>

            <!-- Features -->
            <div class="feature-controls">
                <h3>Input Features</h3>
                <label><input type="checkbox" name="feature" value="x"> X</label>
                <label><input type="checkbox" name="feature" value="y"> Y</label>
                <label><input type="checkbox" name="feature" value="x*y"> X*Y</label>
                <label><input type="checkbox" name="feature" value="x²"> X²</label>
                <label><input type="checkbox" name="feature" value="y²"> Y²</label>
            </div>

            <button onclick="startTraining()">Start Training</button>
        </div>

        <div class="visualization">
            <canvas id="networkCanvas" class="network-canvas" width="800" height="400"></canvas>
            <canvas id="lossChart"></canvas>
        </div>
    </div>

				<script>
				let model;
				let chart;
				let trainingActive = false;
				let networkCanvas = document.getElementById('networkCanvas');
				let ctx = networkCanvas.getContext('2d');
				let layerSizes = [2, 4, 1]; // Initial network architecture

				// Initialize chart
				function initChart() {
					chart = new Chart(document.getElementById('lossChart'), {
						type: 'line',
						data: {
							labels: [],
							datasets: [{
								label: 'Loss',
								data: [],
								borderColor: 'rgb(255, 99, 132)',
								tension: 0.1
							}]
						},
						options: { responsive: true, scales: { y: { beginAtZero: true } } }
					});
				}

				// Network visualization
				function drawNetwork() {
					ctx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);
					
					const layerPadding = 100;
					const neuronRadius = 15;
					const colors = ['#ff7675', '#74b9ff', '#55efc4'];
					
					layerSizes.forEach((neurons, layerIdx) => {
						const xPos = layerPadding + (networkCanvas.width - 2*layerPadding) * 
								(layerIdx / (layerSizes.length - 1));
						
						// Draw neurons
						const ySpacing = networkCanvas.height / (neurons + 1);
						for(let i = 0; i < neurons; i++) {
							ctx.beginPath();
							ctx.arc(xPos, ySpacing * (i+1), neuronRadius, 0, Math.PI * 2);
							ctx.fillStyle = colors[layerIdx % colors.length];
							ctx.fill();
							ctx.stroke();
						}

						// Draw connections
						if(layerIdx > 0) {
							const prevXPos = layerPadding + (networkCanvas.width - 2*layerPadding) * 
										((layerIdx-1) / (layerSizes.length - 1));
							
							const prevYSpacing = networkCanvas.height / (layerSizes[layerIdx-1] + 1);
							const currentYSpacing = networkCanvas.height / (neurons + 1);

							for(let i = 0; i < layerSizes[layerIdx-1]; i++) {
								for(let j = 0; j < neurons; j++) {
									ctx.beginPath();
									ctx.moveTo(prevXPos + neuronRadius, prevYSpacing * (i+1));
									ctx.lineTo(xPos - neuronRadius, currentYSpacing * (j+1));
									ctx.strokeStyle = 'rgba(0,0,0,0.2)';
									ctx.stroke();
								}
							}
						}
					});
				}

				// Model management
				function createModel() {
					model = tf.sequential();
					
					// Input layer
					model.add(tf.layers.dense({
						units: layerSizes[0],
						inputShape: [getSelectedFeatures().length],
						activation: 'relu'
					}));

					// Hidden layers
					for(let i = 1; i < layerSizes.length - 1; i++) {
						model.add(tf.layers.dense({
							units: layerSizes[i],
							activation: 'relu'
						}));
					}

					// Output layer
					model.add(tf.layers.dense({
						units: layerSizes[layerSizes.length - 1],
						activation: 'sigmoid'
					}));

					model.compile({
						optimizer: tf.train.adam(parseFloat(document.getElementById('learningRate').value)),
						loss: 'binaryCrossentropy',
						metrics: ['accuracy']
					});
				}

				// Training data
				function generateData() {
					const numSamples = 1000;
					const xs = tf.randomUniform([numSamples, 2], -1, 1);
					const ys = xs.sum(1).greater(0.5).cast('float32');
					return { xs, ys };
				}

				// Training loop
				async function trainModel() {
					const { xs, ys } = generateData();
					const processedXs = processFeatures(xs);
					
					await model.fit(processedXs, ys, {
						epochs: parseInt(document.getElementById('epochs').value),
						batchSize: parseInt(document.getElementById('batchSize').value),
						callbacks: {
							onEpochEnd: (epoch, logs) => {
								chart.data.labels.push(epoch);
								chart.data.datasets[0].data.push(logs.loss);
								chart.update();
								drawNetwork();
							}
						}
					});
				}

				// Feature processing
				function getSelectedFeatures() {
					return Array.from(document.querySelectorAll('input[name="feature"]:checked'))
							.map(el => el.value);
				}

				function processFeatures(xs) {
					const features = getSelectedFeatures();
					return tf.tidy(() => {
						const x = xs.slice([0,0], [-1,1]);
						const y = xs.slice([0,1], [-1,1]);
						
						const processed = [];
						features.forEach(feat => {
							switch(feat) {
								case 'x': processed.push(x); break;
								case 'y': processed.push(y); break;
								case 'x*y': processed.push(x.mul(y)); break;
								case 'x²': processed.push(x.square()); break;
								case 'y²': processed.push(y.square()); break;
							}
						});
						
						return tf.concat(processed, 1);
					});
				}

				// UI Controls
				function addLayer() {
					layerSizes.splice(-1, 0, 4); // Add hidden layer
					updateLayerControls();
					drawNetwork();
				}

				function removeLayer() {
					if(layerSizes.length > 2) {
						layerSizes.splice(-2, 1);
						updateLayerControls();
						drawNetwork();
					}
				}

				function updateLayerControls() {
					const layerControls = document.getElementById('layerControls');
					layerControls.innerHTML = layerSizes.slice(0, -1).map((size, i) => `
						<div class="layer-control">
							Layer ${i+1}: <input type="number" value="${size}" 
								onchange="layerSizes[${i}] = parseInt(this.value); drawNetwork()">
						</div>
					`).join('');
				}

				// Start training
				async function startTraining() {
					if(trainingActive) return;
					trainingActive = true;
					
					chart.data.labels = [];
					chart.data.datasets[0].data = [];
					chart.update();
					
					createModel();
					await trainModel();
					trainingActive = false;
				}

				// Initialize
				window.onload = () => {
					initChart();
					updateLayerControls();
					drawNetwork();
				};
				</script>

						<div id="sidebar">
						<div class="inner">
			
						
		  
					  <!-- Menu -->
						<nav id="menu">
						  <header class="major">
							<h2>Menu</h2>
						  </header>
						  <ul>
							<li><a href="index.html">Homepage</a></li>
							<li><a href="demo.html">demo</a></li>
							<li><a href="elements.html">Elements</a></li>
							<li><a href="about.html">About</a></li>
							
						  </ul>
						</nav>
		  
					
		  
					  <!-- Section -->
						
					  <!-- Footer -->
						<footer id="footer">
						  Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
						</footer>
		  
					</div>
				  </div>

                </div>
            </div>
        </div>

        <!-- Scripts -->
        <script src="assets/js/jquery.min.js"></script>
        <script src="assets/js/browser.min.js"></script>
        <script src="assets/js/breakpoints.min.js"></script>
        <script src="assets/js/util.js"></script>
        <script src="assets/js/main.js"></script>

        <!-- Add custom demo script -->
       
        </script>
    </body>
</html>